---
title: 图形渲染管线
date: 2019-12-30
tags: [图形渲染管线]
---

通过阅读本文，你将知道：
1. 图形渲染的基本过程是怎样的？
1. 计算机图形学视角下的图形渲染管线是怎样的？
1. OpenGL视角下的图形渲染管线是怎样的？
1. GPU芯片设计者视角下的图形渲染管线是怎样的？

# 图形渲染过程

图形渲染过程可以类比于给模特拍照的过程。

{% asset_img "1.jpg" "Lina" %}

首先我们需要选择一个模特，给模特化妆，选择合适的首饰服装。然后将各种物品以及模特安排在场景的合适位置。接着摄影师调整灯光亮度，设置好相机的各种参数（角度，曝光度等）。最后按下快门，经过打印之后一张图片就生成了。

总结下一张图片的生成过程，大致可以分为四步，分别为：
1. 建模
1. 场景构建
1. 视景体选择
1. 绘制

**第一步 建模**

建模是构建模型的过程。在上述场景中模特以及模特周围的物品都可以看成一个个的模型，选择模特、装扮模特、选择物品都属于建模的过程。

**第二步 场景构建**

场景构建是搭建我们要渲染的整个场景的过程。包含将各个模型放置在合适的位置以及设置好场景的全局属性（如光照、背景色等）。

**第三步 视景体选择**

视景体选择是选择场景展现范围和效果的过程。相机的不同位置、不同角度影响场景的展现范围；相机参数的设置影响场景的展现效果。

**第四步 绘制**

绘制是将图像最终展现到我们眼前的过程。虽然我们已经按下快门，选择了要展现的场景，但是由于打印颜色种类和质量的限制、打印机的设置或者洗照片的化学药剂的成分设置、纸张的长宽比和大小的不同，最终我们看到的图形也会千差万别。

# 计算机图形渲染

计算机图形是用计算机产生的图像。

在给模特拍照的例子中，人、物、场景都是现实中已经存在的，而在计算机图形渲染过程中，他们都需要计算机自己构建。

那怎样用计算机高效地渲染出真实图形呢？计算机图形学应运而生！

计算机图形学就是研究如何在计算机中表示图形，以及利用计算机进行图形的计算、处理和显示的相关原理和算法。

> Computer Graphics is the art of science of producing graphical images with the aid of computer. - IEEE

计算机在图形渲染方面有其局限性。相对于图形渲染过程中的海量数据处理，计算机的计算能力是有限的；计算机图形显示设备是以离散形式显示图形的，比如分辨率为1080p的显示器，其包含的是1920x1080个像素点；计算机的计算精度有限等等。

由此便衍生出来很多优化算法，如：纹理、背面消隐、提前的深度模板测试等。

另外由于人眼的视觉特性，计算机也可以适当偷点懒。如帧率只需要达到34帧/秒，人眼便没有了卡顿感（游戏画面要求达到60帧/秒）；人眼对运动中的画面的细节感知能力很低等。

纹理是最常用的优化措施。例如渲染一个游戏场景中的一棵树，与其使用成千上万个顶点构建这颗树的模型，不如直接使用一张纹理图片来代替。这样做可以极大的提高渲染效率。

从上述可知，计算机图形渲染的输入有两类，分别为：顶点输入和像素输入；计算机图形渲染的输出为：帧缓冲区中的图像。

帧缓冲区中的图像像素会由显示控制器以固有的频率读到显示器上进行显示。

{% asset_img "2.png" "计算机图形渲染管线的输入和输出"%}

计算机图形渲染分为实时渲染和非实时渲染。所谓实时，即快速响应。通常游戏画面的渲染都是实时渲染，计算机制作的电影画面的渲染都是非实时渲染。一个大型游戏的任何时刻截一张图都非常清晰，而电影画面中的高速运动物体的截图则是模糊的。

计算机图形学中并没有明确地定义图形渲染管线，其更多的是研究如何使用计算机更快更好的渲染图形，多偏向于算法方向。图形渲染管线将在后续章节以OpenGL为例进行讲解。

# OpenGL渲染管线

渲染管线可分为可编程渲染管线和固定功能渲染管线。详细介绍请参看《GPU的渲染架构、渲染管线和渲染模式分类》
)

关于`OpenGL渲染管线`，我们可以在各种地方看到这个关键词：计算机图形学、OpenGL官方网站、各大GPU厂商的官网等等。你会发现他们说的都不太一样。

## 计算机图形学视角看OpenGL渲染管线

OpenGL最初的内部流程是一组有序的处理步骤，这些步骤被组织为一个双通道的渲染流水线。流水线阶段当然是固定的---也就是说，它们无论接受到什么样的输入数据都会执行特定的操作---因此，这样的工作方式成为固定功能的OpenGL流水线。

{% asset_img "3.png" "计算机图形学视角下的OpenGL固定功能渲染管线" %}

图中，黑色方框部分一般称为**几何流水线**，Geometry Pipeline；橘色方框部分一般称为**像素流水线**，Pixel Pipeline。

{% asset_img "4.png" "计算机图形学视角下的OpenGL可编程渲染管线" %}

图中，绿色方框部分是可编程的。应用程序通过使用Shader来控制这些阶段内所进行的操作。Shader指的是一些比较短的程序段，它们被加载到OpenGL程序中，并最终加入到OpenGL流水线的适当的处理单元中，替换掉流水线中原来的固定功能。

## 程序员视角看OpenGL渲染管线

使用OpenGL编写应用程序或渲染引擎的程序员所面对的是OpenGL标准API。

在介绍OpenGL标准API展示的渲染管线之前，我们先了解一下OpenGL中的坐标表示。

### OpenGL坐标系

常见的坐标系有：
* 建模坐标系。盒子是什么形状
* 世界坐标系。把盒子放在整个场景中的哪个位置
* 观察和投影坐标系。从哪个角度位置看这个盒子
* 规范化设备坐标系。指定为一个设备无关的坐标系
* 设备坐标系。将最终的图形显示到什么样的设备上

{% asset_img "5.png" "坐标变换" %}

### OpenGL渲染管线
OpenGL官方WIKI上将渲染管线分为7个步骤，分别为：
1. Vertex Specification：指定顶点数据
1. Vertex Processing：顶点处理
1. Vertex Post-Processing：顶点后处理
1. Primitive Assembly：图元装配
1. Rasterization：光栅化
1. Fragment Shader：片段着色
1. Per-Sample Processing ：逐样本处理

{% asset_img "6.png" "OpenGL渲染管线" %}

{% asset_img "7.png" "OpenGL渲染管线" %}

## GPU设计厂商视角看OpenGL渲染管线

和程序员一样，GPU设计厂商面对的也是OpenGL标准API，不同的是，前者是如何使用它们，后者是如何实现它们。

在考虑如何实现他们之前，得先考虑该GPU是应用在什么场景。桌面端的GPU更注重性能，而功耗和面积则非重点考虑因素；移动端的GPU更注重功耗和面积，性能相较于桌面端的GPU则不那么高...

总而言之，GPU设计者需要根据应用场景在功耗、性能和面积组成的三角形中选择一个“完美”的点作为“质心”。

### 驱动程序

GPU设计厂商提供给用户的除了GPU显卡之外，还有驱动程序。驱动程序运行在CPU上。

通常，驱动程序会对OpenGL API进行预处理。OpenGL API会被逐个放到命令缓冲区（软件概念），当遇到一个Draw Terminator做特定处理，当遇到一个Frame Terminator做特定处理。

Draw Terminator通常是:
1. glDrawArrays系列
1. glDrawElements系列
1. glBegin

Frame Terminator通常是:
1. glClear
1. glFlush
1. glFinish
1. SwapBuffers
1. glXMakeCurrent/glXMakeContextCurrent
1. SwapLayerBuffers
1. glFrameTerminatorGREMEDY

这里顺便提一下OpenCL中的Frame Terminator：
1. clFlush
1. clFinish
1. clWaitForEvents
1. cl_gremedy_computation_frame

上述的“特定处理”，不同的GPU是完全不一样的。但他们的核心目的都是将OpenGL API转换成GPU硬件认识的，可以让GPU硬件高效工作的指令和数据。

### GPU硬件渲染管线

{% asset_img "8.png" "GeForce6800" %}

上图是GeForce6800的硬件架构图。其处理流程为：从主机接收到驱动程序发送的指令和数据，先进行顶点着色。然后着色后的顶点进行图元装配，再对图元进行背面消隐、剪裁和光栅化。光栅化产生的片段送到片段着色器进行片段着色，此过程中有可能会用到纹理。着色后的片段再送到ROP单元进行深度模板测试、混合等操作，最后将像素写回帧缓冲区。

上述过程看着和OpenGL官网描述的渲染管线挺像的。其实不然。上图中“ZCull”模块可以提前进行深度模板测试。

理论上，我们甚至可以在OpenGL API和GPU硬件之间再做一层封装，使得GPU硬件和OpenGL描述的渲染管线的逻辑模型的关联很小。随着GPU架构的发展，GPU硬件和OpenGL描述的渲染管线的逻辑模型的关联也确实越来越小。

尝试设计过GPU的人，应该遇到过显示列表这个“坑”。站在程序员角度，显示列表这个特性无可厚非，把一堆OpenGL API放在GPU，方便随时调用。但是GPU设计者要实现这个功能时非常痛苦。

Khronos Group在2015年游戏开发者大会上推出了Vulkan。相对于 OpenGL，Vulkan™ 大幅降低了 CPU 在提供重要特性、性能和影像质量时的“API 开销”，而且可以使用通常通过 OpenGL 无法访问的 GPU 硬件特性。

由此可见，Khronos Group在API设计上，也是对GPU设计者越来越友好。或者说，Khronos Group中有越来越多的GPU设计者参与进来。应用程序开发者的学习成本会略微增加。

# 总结
1. 计算机图形学视角看OpenGL渲染管线，是算法模型；程序员视角看OpenGL渲染管线，是逻辑模型；GPU设计厂商视角看OpenGL渲染管线，是硬件（架构）模型。
1. 图形渲染管线可以分为顶点获取、顶点处理、图元生成、图元处理、片段生成、片段处理共六个阶段。

# 参考
- [Lena的故事](http://www.lenna.org)
- [https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview)
- [https://gpuopen.com/compute-product/codexl/](https://gpuopen.com/compute-product/codexl/)
- 《Realtime Rendering》第四版
- [https://baike.baidu.com/item/Vulkan/17543632?fr=aladdin](https://baike.baidu.com/item/Vulkan/17543632?fr=aladdin)
- 《计算机图形学》第四章
